<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>InceptionDB Console</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <link rel="stylesheet" href="/lib/tailwind.min.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%230f172a'/><text x='50' y='58' font-size='52' text-anchor='middle' fill='white'>IDB</text></svg>">
    <script src="/lib/axios.min.js"></script>
    <script src="/lib/vue.global.prod.js"></script>
  </head>
  <body class="bg-slate-950 text-slate-100 min-h-screen">
    <div id="app" class="min-h-screen flex">
      <aside class="w-72 bg-slate-900 border-r border-slate-800 flex flex-col">
        <div class="px-6 py-5 border-b border-slate-800">
          <div class="flex items-center justify-between">
            <h1 class="text-xl font-semibold tracking-wide">InceptionDB</h1>
            <a
              class="text-slate-400 hover:text-slate-200"
              href="https://github.com/fulldump/inceptiondb"
              target="_blank"
              rel="noopener"
              aria-label="GitHub repository"
            >
              <svg class="w-6 h-6" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                <path
                  fill-rule="evenodd"
                  d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
                  clip-rule="evenodd"
                />
              </svg>
            </a>
          </div>
          <div class="mt-4 rounded-lg border border-slate-800 bg-slate-950/70 p-3">
            <p class="text-xs uppercase tracking-wide text-slate-400">API status</p>
            <div class="mt-2 flex items-center justify-between gap-3">
              <span
                class="inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold"
                :class="connectionStatusBadgeClass"
              >
                <span class="h-2 w-2 rounded-full" :class="connectionStatusDotClass"></span>
                {{ connectionStatusLabel }}
              </span>
              <button
                type="button"
                class="text-xs font-medium text-slate-300 hover:text-white transition disabled:cursor-not-allowed disabled:opacity-50"
                :disabled="connectionStatusChecking"
                @click="refreshConnectionStatus"
              >
                {{ connectionStatusButtonLabel }}
              </button>
            </div>
            <p v-if="connectionStatusDescription" class="mt-2 text-xs text-slate-400">
              {{ connectionStatusDescription }}
            </p>
          </div>
          <button
            type="button"
            class="mt-5 w-full rounded-md border border-slate-700 px-3 py-2 text-sm font-medium text-slate-100 bg-slate-800 hover:bg-slate-700 transition"
            @click="toggleCreateForm"
          >
            {{ createForm.open ? 'Cancel' : 'New collection' }}
          </button>
          <form v-if="createForm.open" class="mt-4 space-y-3" @submit.prevent="createCollection">
            <div>
              <label for="new-collection" class="block text-xs uppercase tracking-wide text-slate-400">Name</label>
              <input
                id="new-collection"
                v-model="createForm.name"
                type="text"
                required
                class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                placeholder="customers"
              >
            </div>
            <button
              type="submit"
              class="w-full rounded-md bg-sky-600 hover:bg-sky-500 px-3 py-2 text-sm font-semibold text-white transition"
            >
              Create collection
            </button>
            <p v-if="createForm.error" class="text-sm text-rose-400">{{ createForm.error }}</p>
          </form>
        </div>
        <div class="flex-1 overflow-y-auto">
          <div v-if="collectionsLoading" class="px-6 py-4 text-sm text-slate-400">Loading collections…</div>
          <div v-else-if="collectionsError" class="px-6 py-4 text-sm text-rose-400">{{ collectionsError }}</div>
          <nav v-else class="py-2">
            <button
              v-for="collection in collections"
              :key="collection.name"
              type="button"
              class="w-full px-6 py-3 text-left hover:bg-slate-800 transition"
              :class="{
                'bg-slate-800 text-sky-300': isSelected(collection.name),
                'text-slate-200': !isSelected(collection.name)
              }"
              @click="selectCollection(collection.name)"
            >
              <div class="flex items-center justify-between text-sm font-medium">
                <span class="truncate">{{ collection.name }}</span>
                <span class="text-xs text-slate-400" v-if="collection.total !== undefined">{{ prettyTotal(collection.total) }}</span>
              </div>
              <p class="mt-1 text-xs text-slate-500" v-if="collection.indexes">{{ collection.indexes }} indexes</p>
            </button>
            <p v-if="collections.length === 0" class="px-6 py-4 text-sm text-slate-500">No collections registered yet.</p>
          </nav>
        </div>
      </aside>

      <main class="flex-1">
        <div v-if="!selectedCollection" class="flex h-full flex-col items-center justify-center text-center gap-3 px-6">
          <h2 class="text-2xl font-semibold text-slate-200">Welcome to InceptionDB</h2>
          <p class="text-slate-400 max-w-md">Select or create a collection in the sidebar to start querying, inserting, or deleting documents.</p>
        </div>

        <div v-else class="flex flex-col gap-6 p-6">
          <header class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
            <div>
              <h2 class="text-2xl font-semibold text-slate-100">Collection {{ selectedCollection.name }}</h2>
              <p class="text-sm text-slate-400 flex flex-wrap items-center gap-3">
                <span v-if="selectedCollection.total !== undefined">Total: {{ selectedCollection.total }}</span>
                <span v-if="queryStats.elapsed">Last query: {{ queryStats.elapsed }}</span>
                <span v-if="queryStats.returned">Documents listed: {{ queryStats.returned }}</span>
              </p>
            </div>
            <div class="flex flex-wrap gap-2">
              <button
                type="button"
                class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-sm font-medium text-slate-200 hover:bg-slate-800 transition"
                @click="runQuery"
              >
                Run query
              </button>
              <button
                type="button"
                class="rounded-md border border-rose-500/40 bg-rose-600/20 px-3 py-2 text-sm font-medium text-rose-300 hover:bg-rose-600/30 transition"
                @click="dropCollection"
              >
                Delete collection
              </button>
            </div>
          </header>

          <section class="grid gap-6 lg:grid-cols-[2fr_1fr]">
            <div class="space-y-6">
              <div class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-5">
                <div>
                  <label for="filter" class="block text-xs uppercase tracking-wide text-slate-400">Filter (JSON)</label>
                  <textarea
                    id="filter"
                    v-model="filterText"
                    rows="4"
                    class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
                    placeholder="{ }"
                  ></textarea>
                  <p v-if="filterError" class="mt-2 text-sm text-rose-400">{{ filterError }}</p>
                </div>

                <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                  <label class="block text-xs uppercase tracking-wide text-slate-400">
                    Items per page
                    <select
                      v-model.number="pageSize"
                      class="mt-1 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                    >
                      <option v-for="size in pageSizeOptions" :key="size" :value="size">{{ size }}</option>
                    </select>
                  </label>
                  <p class="text-xs text-slate-400 md:text-right">{{ pageInfo }}</p>
                </div>

                <div>
                  <label class="block text-xs uppercase tracking-wide text-slate-400">Index</label>
                  <select
                    v-model="selectedIndexName"
                    class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                  >
                    <option value="">No index (full scan)</option>
                    <option v-for="index in indexes" :key="index.name" :value="index.name">
                      {{ index.name }} · {{ index.type }}
                    </option>
                  </select>
                </div>

                <div v-if="activeIndex && activeIndex.type === 'map'" class="grid gap-2">
                  <label class="block text-xs uppercase tracking-wide text-slate-400">Index value</label>
                  <input
                    type="text"
                    v-model="mapValue"
                    class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                    placeholder="Enter a unique value"
                  >
                </div>

                <div v-if="activeIndex && activeIndex.type === 'btree'" class="space-y-4">
                  <div>
                    <span class="block text-xs uppercase tracking-wide text-slate-400 mb-2">From (inclusive)</span>
                    <div class="grid gap-3 md:grid-cols-2">
                      <label v-for="field in activeIndex.fields" :key="'from-' + field" class="text-sm text-slate-300">
                        <span class="block text-xs uppercase tracking-wide text-slate-500">{{ field }}</span>
                        <input
                          type="text"
                          v-model="rangeFrom[field]"
                          class="mt-1 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                        >
                      </label>
                    </div>
                  </div>
                  <div>
                    <span class="block text-xs uppercase tracking-wide text-slate-400 mb-2">To (exclusive)</span>
                    <div class="grid gap-3 md:grid-cols-2">
                      <label v-for="field in activeIndex.fields" :key="'to-' + field" class="text-sm text-slate-300">
                        <span class="block text-xs uppercase tracking-wide text-slate-500">{{ field }}</span>
                        <input
                          type="text"
                          v-model="rangeTo[field]"
                          class="mt-1 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                        >
                      </label>
                    </div>
                  </div>
                  <label class="inline-flex items-center gap-2 text-sm text-slate-300">
                    <input type="checkbox" v-model="reverse" class="h-4 w-4 rounded border-slate-700 bg-slate-900">
                    Reverse order
                  </label>
                </div>

                <div class="flex flex-wrap justify-end gap-2">
                  <button
                    type="button"
                    class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-sm text-slate-200 hover:bg-slate-800 transition"
                    :disabled="disablePrev"
                    @click="prevPage"
                  >
                    Previous
                  </button>
                  <button
                    type="button"
                    class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-sm text-slate-200 hover:bg-slate-800 transition"
                    :disabled="disableNext"
                    @click="nextPage"
                  >
                    Next
                  </button>
                </div>
              </div>

              <div class="rounded-xl border border-slate-800 bg-slate-900/60 shadow-inner">
                <div class="border-b border-slate-800 px-5 py-3 text-sm font-semibold text-slate-200">Results</div>
                <p class="px-5 pt-3 text-xs text-slate-400">Default view: JSON list of the first documents in the selected collection.</p>
                <div class="p-5 space-y-4">
                  <div v-if="queryLoading" class="text-sm text-slate-400">Running query…</div>
                  <div v-else-if="queryError" class="text-sm text-rose-400">{{ queryError }}</div>
                  <div v-else-if="queryRows.length === 0" class="text-sm text-slate-400">No documents found.</div>
                  <div v-else class="space-y-4">
                    <div
                      v-for="(row, idx) in queryRows"
                      :key="idx"
                      class="rounded-lg border border-slate-800 bg-slate-950 p-4"
                    >
                      <div class="mb-3 flex flex-wrap items-center justify-between gap-2 text-xs text-slate-500">
                        <span class="text-xs text-slate-400">Document #{{ offset + idx + 1 }}</span>
                        <div v-if="canEditRow(row) || canDeleteRow(row)" class="flex items-center gap-2">
                          <button
                            v-if="canEditRow(row)"
                            type="button"
                            class="rounded-md border border-sky-500/40 bg-sky-600/20 px-2 py-1 text-xs font-semibold text-sky-200 hover:bg-sky-600/30 transition"
                            @click="openEditDialog(row)"
                          >
                            Edit
                          </button>
                          <button
                            v-if="canDeleteRow(row)"
                            type="button"
                            class="rounded-md border border-rose-500/40 bg-rose-600/20 px-2 py-1 text-xs font-semibold text-rose-200 hover:bg-rose-600/30 transition"
                            @click="deleteRow(row)"
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                      <pre class="whitespace-pre-wrap break-words text-sm text-slate-200 font-mono">{{ formatDocument(row) }}</pre>
                      <p
                        v-if="!(canEditRow(row) || canDeleteRow(row)) && activeIndex && activeIndex.type === 'map'"
                        class="mt-3 text-xs text-slate-500"
                      >
                        The document does not contain the "{{ activeIndex.field }}" field required for editing or deletion.
                      </p>
                      <p v-else-if="activeIndex && activeIndex.type !== 'map'" class="mt-3 text-xs text-slate-500">
                        Select a "map" index to enable editing and deletion.
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="space-y-6">
              <div class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-4">
                <h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Insert document</h3>
                <textarea
                  v-model="insertForm.payload"
                  rows="8"
                  class="w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
                  placeholder='{"name": "Ada"}'
                ></textarea>
                <div class="flex justify-end">
                  <button
                    type="button"
                    class="rounded-md bg-sky-600 px-4 py-2 text-sm font-semibold text-white hover:bg-sky-500 transition"
                    @click="insertDocument"
                  >
                    Insert
                  </button>
                </div>
                <p v-if="insertForm.error" class="text-sm text-rose-400">{{ insertForm.error }}</p>
                <p v-else-if="insertForm.success" class="text-sm text-emerald-400">{{ insertForm.success }}</p>
              </div>

              <div class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-4">
                <div class="flex items-center justify-between gap-3">
                  <h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Indexes</h3>
                  <button
                    type="button"
                    class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
                    @click="toggleIndexForm"
                  >
                    {{ indexForm.open ? 'Cancel' : 'New index' }}
                  </button>
                </div>
                <p v-if="indexMessages.error" class="text-sm text-rose-400">{{ indexMessages.error }}</p>
                <p v-else-if="indexMessages.success" class="text-sm text-emerald-400">{{ indexMessages.success }}</p>
                <form
                  v-if="indexForm.open"
                  class="space-y-3 rounded-lg border border-slate-800/70 bg-slate-950/60 p-4"
                  @submit.prevent="createIndex"
                >
                  <div>
                    <label for="index-name" class="block text-xs uppercase tracking-wide text-slate-400">Name</label>
                    <input
                      id="index-name"
                      v-model="indexForm.name"
                      type="text"
                      required
                      class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                      placeholder="by_email"
                    >
                  </div>
                  <div>
                    <label for="index-type" class="block text-xs uppercase tracking-wide text-slate-400">Type</label>
                    <select
                      id="index-type"
                      v-model="indexForm.type"
                      class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                    >
                      <option value="map">Map</option>
                      <option value="btree">B-Tree</option>
                    </select>
                  </div>
                  <div v-if="indexForm.type === 'map'" class="space-y-2">
                    <div>
                      <label for="index-field" class="block text-xs uppercase tracking-wide text-slate-400">Field</label>
                      <input
                        id="index-field"
                        v-model="indexForm.field"
                        type="text"
                        required
                        class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                        placeholder="email"
                      >
                    </div>
                    <label class="inline-flex items-center gap-2 text-xs text-slate-300">
                      <input type="checkbox" v-model="indexForm.sparse" class="h-4 w-4 rounded border-slate-700 bg-slate-900">
                      Sparse (ignore documents without the field)
                    </label>
                  </div>
                  <div v-else class="space-y-2">
                    <div>
                      <label for="index-fields" class="block text-xs uppercase tracking-wide text-slate-400">Fields</label>
                      <input
                        id="index-fields"
                        v-model="indexForm.fieldsText"
                        type="text"
                        required
                        class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500"
                        placeholder="lastName, firstName"
                      >
                      <p class="mt-1 text-[11px] text-slate-500">
                        Separate fields with commas. Prefix with "-" for descending order.
                      </p>
                    </div>
                    <label class="inline-flex items-center gap-2 text-xs text-slate-300">
                      <input type="checkbox" v-model="indexForm.sparse" class="h-4 w-4 rounded border-slate-700 bg-slate-900">
                      Sparse (ignore documents missing the fields)
                    </label>
                    <label class="inline-flex items-center gap-2 text-xs text-slate-300">
                      <input type="checkbox" v-model="indexForm.unique" class="h-4 w-4 rounded border-slate-700 bg-slate-900">
                      Unique (reject duplicate combinations)
                    </label>
                  </div>
                  <div class="flex justify-end gap-2">
                    <button
                      type="button"
                      class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition"
                      @click="toggleIndexForm"
                    >
                      Cancel
                    </button>
                    <button
                      type="submit"
                      class="rounded-md bg-sky-600 px-3 py-2 text-xs font-semibold text-white hover:bg-sky-500 transition disabled:cursor-not-allowed disabled:opacity-60"
                      :disabled="indexForm.submitting"
                    >
                      {{ indexForm.submitting ? 'Creating…' : 'Create index' }}
                    </button>
                  </div>
                </form>
                <div v-if="indexesLoading" class="text-sm text-slate-400">Loading indexes…</div>
                <div v-else-if="indexes.length === 0" class="text-sm text-slate-400">This collection has no indexes yet.</div>
                <ul v-else class="space-y-3 text-sm text-slate-300">
                  <li
                    v-for="index in indexes"
                    :key="index.name"
                    class="rounded-lg border border-slate-800 bg-slate-950 p-3"
                  >
                    <div class="flex items-start justify-between gap-3">
                      <div class="space-y-2">
                        <div class="flex items-center gap-2 text-slate-200">
                          <span class="font-semibold">{{ index.name }}</span>
                          <span class="rounded-full border border-slate-700/80 bg-slate-900 px-2 py-0.5 text-[11px] uppercase tracking-wide text-slate-400">
                            {{ index.type === 'btree' ? 'B-Tree' : 'Map' }}
                          </span>
                        </div>
                        <p v-if="index.type === 'map'" class="text-xs text-slate-400">Field: {{ index.field }}</p>
                        <p v-else-if="index.type === 'btree'" class="text-xs text-slate-400">Fields: {{ Array.isArray(index.fields) ? index.fields.join(', ') : '' }}</p>
                        <div class="flex flex-wrap gap-2 text-[11px] uppercase tracking-wide text-slate-400">
                          <span v-if="index.unique" class="rounded bg-slate-800 px-2 py-0.5 text-emerald-300/90">Unique</span>
                          <span v-if="index.sparse" class="rounded bg-slate-800 px-2 py-0.5 text-slate-200/80">Sparse</span>
                        </div>
                      </div>
                      <button
                        type="button"
                        class="rounded-md border border-rose-500/40 bg-rose-600/20 px-2 py-1 text-xs font-semibold text-rose-200 hover:bg-rose-600/30 transition"
                        @click="removeIndex(index)"
                      >
                        Delete
                      </button>
                    </div>
                  </li>
                </ul>
              </div>

              <div class="rounded-xl border border-slate-800 bg-slate-900/60 p-5 shadow-inner space-y-4">
                <div class="flex items-start justify-between gap-3">
                  <div>
                    <h3 class="text-sm font-semibold text-slate-200 uppercase tracking-wide">Activity log</h3>
                    <p class="mt-1 text-xs text-slate-400">Latest API calls for this session.</p>
                  </div>
                  <button
                    type="button"
                    class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="activityLog.length === 0"
                    @click="clearActivityLog"
                  >
                    Clear log
                  </button>
                </div>
                <div v-if="activityLog.length === 0" class="text-sm text-slate-400">No activity recorded yet.</div>
                <ul v-else class="space-y-3">
                  <li
                    v-for="entry in activityLog"
                    :key="entry.id"
                    class="rounded-lg border border-slate-800 bg-slate-950 p-3 space-y-2"
                  >
                    <div class="flex items-start justify-between gap-3">
                      <div class="space-y-1 min-w-0">
                        <p class="text-sm font-semibold text-slate-200 flex flex-wrap items-baseline gap-2">
                          <span class="text-[11px] uppercase tracking-wide text-slate-500">{{ entry.method }}</span>
                          <span class="truncate">{{ entry.label }}</span>
                        </p>
                        <p class="text-xs text-slate-500 break-all">{{ entry.url }}</p>
                        <p v-if="entry.target" class="text-[11px] uppercase tracking-wide text-slate-500">Target: {{ entry.target }}</p>
                      </div>
                      <span
                        class="inline-flex items-center rounded-full border px-2 py-0.5 text-[11px] font-semibold uppercase tracking-wide"
                        :class="activityStatusBadgeClass(entry.status)"
                      >
                        {{ activityStatusLabel(entry.status) }}
                      </span>
                    </div>
                    <div class="flex flex-wrap items-center justify-between gap-2 text-xs text-slate-400">
                      <span>{{ formatActivityTime(entry.startedAt) }}</span>
                      <span v-if="entry.durationMs !== null">{{ formatDuration(entry.durationMs) }}</span>
                    </div>
                    <p class="text-xs text-slate-300">{{ entry.detail }}</p>
                    <p v-if="entry.statusCode" class="text-[11px] uppercase tracking-wide text-slate-500">HTTP {{ entry.statusCode }}</p>
                  </li>
                </ul>
              </div>
            </div>
          </section>
        </div>
      </main>
    </div>

    <div
      v-if="editDialog.open"
      class="fixed inset-0 z-50 flex items-center justify-center bg-slate-950/80 px-4"
      role="dialog"
      aria-modal="true"
    >
      <div class="w-full max-w-3xl overflow-hidden rounded-xl border border-slate-800 bg-slate-900 shadow-xl">
        <header class="flex items-start justify-between gap-3 border-b border-slate-800 px-6 py-4">
          <div class="space-y-1">
            <h3 class="text-lg font-semibold text-slate-100">Edit document</h3>
            <p class="text-xs text-slate-400">
              Updating document where {{ editDialog.indexField }} = {{ editDialog.valueLabel }} in collection
              "{{ editDialog.collectionName }}".
            </p>
          </div>
          <button
            type="button"
            class="rounded-md border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-semibold text-slate-200 hover:bg-slate-800 transition disabled:opacity-50 disabled:cursor-not-allowed"
            @click="closeEditDialog"
            :disabled="editDialog.saving"
          >
            Close
          </button>
        </header>
        <form class="space-y-4 px-6 py-5" @submit.prevent="submitEdit">
          <div>
            <label class="block text-xs uppercase tracking-wide text-slate-400">Document (JSON)</label>
            <textarea
              v-model="editDialog.text"
              rows="12"
              class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm font-mono text-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500 disabled:opacity-70"
              :disabled="editDialog.saving"
            ></textarea>
          </div>
          <p v-if="editDialog.error" class="text-sm text-rose-400">{{ editDialog.error }}</p>
          <div class="flex justify-end gap-3">
            <button
              type="button"
              class="rounded-md border border-slate-700 bg-slate-900 px-3 py-2 text-sm font-semibold text-slate-200 hover:bg-slate-800 transition disabled:opacity-50 disabled:cursor-not-allowed"
              @click="closeEditDialog"
              :disabled="editDialog.saving"
            >
              Cancel
            </button>
            <button
              type="submit"
              class="rounded-md bg-sky-600 px-4 py-2 text-sm font-semibold text-white hover:bg-sky-500 transition disabled:cursor-not-allowed disabled:opacity-70"
              :disabled="editDialog.saving"
            >
              {{ editDialog.saving ? 'Saving…' : 'Save changes' }}
            </button>
          </div>
        </form>
      </div>
    </div>

    <script>
      const { createApp, ref, reactive, computed, watch, onMounted, onBeforeUnmount } = Vue;

      createApp({
        setup() {
          const collections = ref([]);
          const collectionsLoading = ref(false);
          const collectionsError = ref('');
          const selectedCollectionName = ref('');
          const indexes = ref([]);
          const indexesLoading = ref(false);
          const filterText = ref('{\n\n}');
          const filterError = ref('');
          const page = ref(1);
          const pageSize = ref(25);
          const pageSizeOptions = [10, 25, 50, 100];
          const queryRows = ref([]);
          const queryLoading = ref(false);
          const queryError = ref('');
          const queryStats = reactive({ elapsed: '', returned: 0 });
          const selectedIndexName = ref('');
          const mapValue = ref('');
          const reverse = ref(false);
          const rangeFrom = reactive({});
          const rangeTo = reactive({});
          const insertForm = reactive({ payload: '{\n\n}', error: '', success: '' });
          const createForm = reactive({ open: false, name: '', error: '' });
          const indexForm = reactive({
            open: false,
            name: '',
            type: 'map',
            field: '',
            fieldsText: '',
            sparse: false,
            unique: false,
            submitting: false,
          });
          const indexMessages = reactive({ error: '', success: '' });
          const connectionStatus = reactive({
            state: 'unknown',
            detail: 'Waiting for first response.',
            checkedAt: null,
            isChecking: false,
          });
          const MAX_ACTIVITY_LOG_ENTRIES = 50;
          const activityLog = ref([]);
          const editDialog = reactive({
            open: false,
            text: '',
            error: '',
            saving: false,
            indexField: '',
            indexName: '',
            indexValue: null,
            valueLabel: '',
            original: null,
            collectionName: '',
          });

          const timeFormatter = new Intl.DateTimeFormat('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            second: '2-digit',
            hour12: true,
          });

          const createActivityEntry = ({ label, method, url, target }) => {
            const entry = {
              id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
              label,
              method,
              url,
              target: target || '',
              status: 'pending',
              statusCode: null,
              detail: 'Waiting for response…',
              startedAt: new Date(),
              finishedAt: null,
              durationMs: null,
            };
            activityLog.value.unshift(entry);
            if (activityLog.value.length > MAX_ACTIVITY_LOG_ENTRIES) {
              activityLog.value.splice(MAX_ACTIVITY_LOG_ENTRIES);
            }
            return entry;
          };

          const completeActivityEntry = (entry, { status = 'success', detail = '', statusCode } = {}) => {
            if (!entry) return;
            entry.status = status;
            entry.detail = detail;
            if (typeof statusCode === 'number') {
              entry.statusCode = statusCode;
            }
            entry.finishedAt = new Date();
            entry.durationMs = entry.finishedAt - entry.startedAt;
          };

          const failActivityEntry = (entry, error, { fallback } = {}) => {
            if (!entry) return;
            const statusCode = error?.response?.status;
            const detail = error?.response?.data?.error || error?.message || fallback || 'Request failed.';
            completeActivityEntry(entry, { status: 'error', detail, statusCode });
          };

          const formatDuration = (ms) => {
            if (typeof ms !== 'number' || Number.isNaN(ms)) return '';
            if (ms < 1000) return `${ms} ms`;
            if (ms < 10000) return `${(ms / 1000).toFixed(2)} s`;
            return `${(ms / 1000).toFixed(1)} s`;
          };

          const formatActivityTime = (date) => {
            if (!(date instanceof Date)) return '';
            return timeFormatter.format(date);
          };

          const activityStatusLabel = (status) => {
            switch (status) {
              case 'success':
                return 'Success';
              case 'error':
                return 'Failed';
              default:
                return 'Pending';
            }
          };

          const activityStatusBadgeClass = (status) => {
            switch (status) {
              case 'success':
                return 'border-emerald-500/40 bg-emerald-500/10 text-emerald-300';
              case 'error':
                return 'border-rose-500/40 bg-rose-500/10 text-rose-300';
              default:
                return 'border-sky-500/40 bg-sky-500/10 text-sky-300';
            }
          };

          const clearActivityLog = () => {
            activityLog.value = [];
          };

          const connectionStatusLabel = computed(() => {
            if (connectionStatus.state === 'online') return 'Connected';
            if (connectionStatus.state === 'degraded') return 'Degraded';
            if (connectionStatus.state === 'offline') return 'Offline';
            return connectionStatus.isChecking ? 'Checking…' : 'Unknown';
          });

          const connectionStatusDescription = computed(() => {
            if (connectionStatus.state === 'unknown' && connectionStatus.isChecking) {
              return 'Verifying API availability…';
            }
            const segments = [];
            if (connectionStatus.detail) segments.push(connectionStatus.detail);
            if (connectionStatus.checkedAt instanceof Date) {
              segments.push(`Updated at ${timeFormatter.format(connectionStatus.checkedAt)}`);
            }
            return segments.join(' • ');
          });

          const connectionStatusBadgeClass = computed(() => {
            switch (connectionStatus.state) {
              case 'online':
                return 'border border-emerald-500/40 bg-emerald-500/10 text-emerald-200';
              case 'degraded':
                return 'border border-amber-500/40 bg-amber-500/10 text-amber-200';
              case 'offline':
                return 'border border-rose-500/40 bg-rose-500/10 text-rose-200';
              default:
                return 'border border-slate-500/30 bg-slate-500/10 text-slate-200';
            }
          });

          const connectionStatusDotClass = computed(() => {
            const base = 'h-2 w-2 rounded-full';
            const pulse = connectionStatus.isChecking ? ' animate-pulse' : '';
            switch (connectionStatus.state) {
              case 'online':
                return base + ' bg-emerald-400' + pulse;
              case 'degraded':
                return base + ' bg-amber-400' + pulse;
              case 'offline':
                return base + ' bg-rose-400' + pulse;
              default:
                return base + ' bg-slate-300' + pulse;
            }
          });

          const connectionStatusButtonLabel = computed(() => (connectionStatus.isChecking ? 'Checking…' : 'Check now'));
          const connectionStatusChecking = computed(() => connectionStatus.isChecking);

          const selectedCollection = computed(() => collections.value.find(c => c.name === selectedCollectionName.value) || null);
          const activeIndex = computed(() => indexes.value.find(idx => idx.name === selectedIndexName.value) || null);
          const offset = computed(() => Math.max(0, (Number(page.value) - 1) * Number(pageSize.value || 0)));
          const disablePrev = computed(() => page.value <= 1);
          const disableNext = computed(() => {
            const limit = Number(pageSize.value) || 0;
            if (limit === 0) return true;
            return queryRows.value.length < limit;
          });
          const pageInfo = computed(() => {
            const count = queryRows.value.length;
            if (count === 0) {
              return 'No results on this page.';
            }
            const start = offset.value + 1;
            const end = offset.value + count;
            const total = selectedCollection.value?.total;
            if (typeof total === 'number') {
              return `Showing ${start}–${end} of ${total}`;
            }
            return `Showing ${start}–${end}`;
          });

          const prettyTotal = (n) => {
            if (typeof n !== 'number') return n;
            if (n >= 1_000_000) return (n / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
            if (n >= 1_000) return (n / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
            return n;
          };

          const formatValueLabel = (value) => {
            if (typeof value === 'string') {
              return `"${value}"`;
            }
            if (typeof value === 'number' || typeof value === 'boolean') {
              return String(value);
            }
            if (value === null) {
              return 'null';
            }
            try {
              return JSON.stringify(value);
            } catch (err) {
              return String(value);
            }
          };

          const isPlainObject = (value) => value !== null && typeof value === 'object' && !Array.isArray(value);

          const deepEqual = (a, b) => {
            if (a === b) return true;
            if (Number.isNaN(a) && Number.isNaN(b)) return true;
            if (typeof a !== typeof b) return false;
            if (a === null || b === null) return a === b;
            if (Array.isArray(a) && Array.isArray(b)) {
              if (a.length !== b.length) return false;
              for (let i = 0; i < a.length; i += 1) {
                if (!deepEqual(a[i], b[i])) return false;
              }
              return true;
            }
            if (isPlainObject(a) && isPlainObject(b)) {
              const keysA = Object.keys(a);
              const keysB = Object.keys(b);
              if (keysA.length !== keysB.length) return false;
              for (const key of keysA) {
                if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
                if (!deepEqual(a[key], b[key])) return false;
              }
              return true;
            }
            return false;
          };

          const buildPatchObject = (original, updated) => {
            if (deepEqual(original, updated)) {
              return {};
            }
            if (!isPlainObject(original) || !isPlainObject(updated)) {
              return updated;
            }
            const patch = {};
            const keys = new Set([...Object.keys(original), ...Object.keys(updated)]);
            keys.forEach((key) => {
              if (!Object.prototype.hasOwnProperty.call(updated, key)) {
                patch[key] = null;
                return;
              }
              const origVal = original[key];
              const newVal = updated[key];
              if (deepEqual(origVal, newVal)) {
                return;
              }
              if (isPlainObject(origVal) && isPlainObject(newVal)) {
                const nestedPatch = buildPatchObject(origVal, newVal);
                if (isPlainObject(nestedPatch) && Object.keys(nestedPatch).length === 0) {
                  return;
                }
                patch[key] = nestedPatch;
              } else {
                patch[key] = newVal;
              }
            });
            return patch;
          };

          const isSelected = (name) => selectedCollectionName.value === name;

          const toggleCreateForm = () => {
            createForm.open = !createForm.open;
            createForm.error = '';
          };

          const resetIndexForm = () => {
            indexForm.name = '';
            indexForm.type = 'map';
            indexForm.field = '';
            indexForm.fieldsText = '';
            indexForm.sparse = false;
            indexForm.unique = false;
            indexForm.submitting = false;
          };

          const toggleIndexForm = () => {
            if (indexForm.open) {
              indexForm.open = false;
            } else {
              resetIndexForm();
              indexForm.open = true;
            }
            indexMessages.error = '';
            indexMessages.success = '';
          };

          const createIndex = async () => {
            if (!selectedCollection.value || indexForm.submitting) return;
            indexMessages.error = '';
            indexMessages.success = '';
            const name = indexForm.name.trim();
            if (!name) {
              indexMessages.error = 'Provide a name for the index.';
              return;
            }
            const payload = {
              name,
              type: indexForm.type,
            };
            if (indexForm.type === 'map') {
              const field = indexForm.field.trim();
              if (!field) {
                indexMessages.error = 'Provide the field to index.';
                return;
              }
              payload.field = field;
              payload.sparse = !!indexForm.sparse;
            } else if (indexForm.type === 'btree') {
              const fields = indexForm.fieldsText
                .split(',')
                .map((part) => part.trim())
                .filter(Boolean);
              if (!fields.length) {
                indexMessages.error = 'Add at least one field for the index.';
                return;
              }
              payload.fields = fields;
              payload.sparse = !!indexForm.sparse;
              payload.unique = !!indexForm.unique;
            } else {
              indexMessages.error = 'Unsupported index type.';
              return;
            }
            indexForm.submitting = true;
            const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:createIndex`;
            const entry = createActivityEntry({
              label: `Create index ${name}`,
              method: 'POST',
              url,
              target: selectedCollection.value.name,
            });
            try {
              const resp = await axios.post(url, payload);
              markConnectionOnline();
              indexMessages.success = `Index "${name}" created successfully.`;
              indexForm.open = false;
              resetIndexForm();
              completeActivityEntry(entry, {
                detail: `Index "${name}" created successfully.`,
                statusCode: resp.status,
              });
              await loadIndexes();
              selectedIndexName.value = name;
            } catch (error) {
              indexMessages.error = error?.response?.data?.error || 'Failed to create the index.';
              failActivityEntry(entry, error, { fallback: 'Failed to create the index.' });
              handleRequestError(error);
            } finally {
              indexForm.submitting = false;
            }
          };

          const removeIndex = async (index) => {
            if (!selectedCollection.value) return;
            indexMessages.error = '';
            indexMessages.success = '';
            const confirmMessage = `Delete the index "${index.name}"? This action cannot be undone.`;
            const ok = window.confirm(confirmMessage);
            if (!ok) return;
            const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:dropIndex`;
            const entry = createActivityEntry({
              label: `Delete index ${index.name}`,
              method: 'POST',
              url,
              target: selectedCollection.value.name,
            });
            try {
              const resp = await axios.post(url, { name: index.name });
              markConnectionOnline();
              if (selectedIndexName.value === index.name) {
                selectedIndexName.value = '';
              }
              indexMessages.success = `Index "${index.name}" deleted successfully.`;
              completeActivityEntry(entry, {
                detail: `Index "${index.name}" deleted successfully.`,
                statusCode: resp.status,
              });
              await loadIndexes();
            } catch (error) {
              indexMessages.error = error?.response?.data?.error || 'Failed to delete the index.';
              failActivityEntry(entry, error, { fallback: 'Failed to delete the index.' });
              handleRequestError(error);
            }
          };

          const markConnectionOnline = (detail = 'All systems operational') => {
            connectionStatus.state = 'online';
            connectionStatus.detail = detail;
            connectionStatus.checkedAt = new Date();
            connectionStatus.isChecking = false;
          };

          const markConnectionDegraded = (detail) => {
            connectionStatus.state = 'degraded';
            connectionStatus.detail = detail;
            connectionStatus.checkedAt = new Date();
            connectionStatus.isChecking = false;
          };

          const markConnectionOffline = (detail) => {
            connectionStatus.state = 'offline';
            connectionStatus.detail = detail;
            connectionStatus.checkedAt = new Date();
            connectionStatus.isChecking = false;
          };

          const beginConnectionCheck = () => {
            connectionStatus.isChecking = true;
            if (connectionStatus.state === 'unknown') {
              connectionStatus.detail = 'Checking backend status…';
            }
          };

          const handleRequestError = (error, { context = 'request' } = {}) => {
            if (error?.response) {
              const status = Number(error.response.status);
              if (status >= 500) {
                markConnectionDegraded(`Server error (HTTP ${status})`);
              } else if (context === 'check') {
                markConnectionDegraded(`Unexpected response (HTTP ${status})`);
              } else {
                connectionStatus.isChecking = false;
              }
            } else {
              const message = error?.message ? `Network error: ${error.message}` : 'Unable to reach the API.';
              markConnectionOffline(message);
            }
            return error;
          };

          let statusPoller = null;
          let statusPromise = null;

          const checkBackendStatus = async () => {
            if (statusPromise) return statusPromise;
            beginConnectionCheck();
            statusPromise = axios
              .get('/v1/collections')
              .then(() => {
                markConnectionOnline();
              })
              .catch((error) => {
                handleRequestError(error, { context: 'check' });
              })
              .finally(() => {
                connectionStatus.isChecking = false;
                statusPromise = null;
              });
            return statusPromise;
          };

          const refreshConnectionStatus = () => {
            if (connectionStatus.isChecking) return;
            checkBackendStatus();
          };

          const selectCollection = (name) => {
            if (selectedCollectionName.value === name) {
              selectedCollectionName.value = '';
            } else {
              selectedCollectionName.value = name;
            }
          };

          const resetRangeFields = () => {
            Object.keys(rangeFrom).forEach((key) => delete rangeFrom[key]);
            Object.keys(rangeTo).forEach((key) => delete rangeTo[key]);
            const index = activeIndex.value;
            if (index && index.type === 'btree') {
              (index.fields || []).forEach((field) => {
                rangeFrom[field] = '';
                rangeTo[field] = '';
              });
            }
          };

          const closeEditDialog = () => {
            editDialog.open = false;
            editDialog.text = '';
            editDialog.error = '';
            editDialog.saving = false;
            editDialog.indexField = '';
            editDialog.indexName = '';
            editDialog.indexValue = null;
            editDialog.valueLabel = '';
            editDialog.original = null;
            editDialog.collectionName = '';
          };

          const openEditDialog = (row) => {
            if (!selectedCollection.value || !canEditRow(row)) return;
            const index = activeIndex.value;
            const value = row[index.field];
            let originalCopy;
            try {
              originalCopy = JSON.parse(JSON.stringify(row));
            } catch (err) {
              editDialog.error = 'Failed to prepare the document for editing.';
              return;
            }
            editDialog.indexField = index.field;
            editDialog.indexName = index.name;
            editDialog.indexValue = value;
            editDialog.collectionName = selectedCollection.value.name;
            editDialog.valueLabel = formatValueLabel(value);
            editDialog.text = JSON.stringify(originalCopy, null, 2);
            editDialog.original = originalCopy;
            editDialog.error = '';
            editDialog.saving = false;
            editDialog.open = true;
          };

          const submitEdit = async () => {
            if (!editDialog.open) return;
            editDialog.error = '';
            let parsed;
            try {
              parsed = JSON.parse(editDialog.text);
            } catch (err) {
              editDialog.error = 'Invalid JSON: ' + err.message;
              return;
            }
            if (!isPlainObject(parsed)) {
              editDialog.error = 'The document must be a JSON object.';
              return;
            }
            if (!isPlainObject(editDialog.original)) {
              editDialog.error = 'The original document is not available for comparison.';
              return;
            }
            const patch = buildPatchObject(editDialog.original, parsed);
            if (!patch || (isPlainObject(patch) && Object.keys(patch).length === 0)) {
              editDialog.error = 'No changes detected.';
              return;
            }
            const collectionName = editDialog.collectionName || selectedCollection.value?.name;
            if (!collectionName) {
              editDialog.error = 'Select a collection before editing.';
              return;
            }
            const indexName = editDialog.indexName;
            const indexField = editDialog.indexField;
            const indexValue = editDialog.indexValue;
            if (!indexName || indexValue === undefined) {
              editDialog.error = 'Index information is missing.';
              return;
            }
            const url = `/v1/collections/${encodeURIComponent(collectionName)}:patch`;
            editDialog.saving = true;
            const entry = createActivityEntry({
              label: `Update document by ${indexField}`,
              method: 'POST',
              url,
              target: collectionName,
            });
            try {
              const resp = await axios.post(url, {
                index: indexName,
                value: indexValue,
                patch,
              });
              markConnectionOnline();
              completeActivityEntry(entry, {
                detail: `Updated document where ${indexField} = ${editDialog.valueLabel}.`,
                statusCode: resp.status,
              });
              closeEditDialog();
              await runQuery();
              await loadCollections();
            } catch (error) {
              editDialog.error = error?.response?.data?.error || 'Failed to update the document.';
              failActivityEntry(entry, error, { fallback: 'Failed to update the document.' });
              handleRequestError(error);
            } finally {
              editDialog.saving = false;
            }
          };

          watch(
            () => indexForm.type,
            () => {
              indexForm.field = '';
              indexForm.fieldsText = '';
              indexForm.sparse = false;
              indexForm.unique = false;
              indexMessages.error = '';
            },
          );

          watch(activeIndex, () => {
            mapValue.value = '';
            reverse.value = false;
            resetRangeFields();
            if (editDialog.open) {
              closeEditDialog();
            }
          });

          watch(selectedCollection, async (collection) => {
            indexes.value = [];
            selectedIndexName.value = '';
            mapValue.value = '';
            reverse.value = false;
            resetRangeFields();
            filterText.value = '{\n\n}';
            filterError.value = '';
            page.value = 1;
            queryRows.value = [];
            queryError.value = '';
            queryStats.elapsed = '';
            queryStats.returned = 0;
            indexForm.open = false;
            resetIndexForm();
            indexMessages.error = '';
            indexMessages.success = '';
            if (editDialog.open) {
              closeEditDialog();
            }
            if (collection) {
              await loadIndexes();
              await runQuery();
            }
          });

          const loadCollections = async () => {
            collectionsLoading.value = true;
            collectionsError.value = '';
            const entry = createActivityEntry({
              label: 'List collections',
              method: 'GET',
              url: '/v1/collections',
            });
            try {
              const resp = await axios.get('/v1/collections');
              markConnectionOnline();
              const list = Array.isArray(resp.data) ? resp.data.slice() : [];
              list.sort((a, b) => a.name.localeCompare(b.name));
              collections.value = list;
              completeActivityEntry(entry, {
                detail: `Loaded ${list.length} collections.`,
                statusCode: resp.status,
              });
              if (selectedCollectionName.value) {
                const exists = list.some((item) => item.name === selectedCollectionName.value);
                if (!exists) {
                  selectedCollectionName.value = '';
                }
              }
            } catch (error) {
              collectionsError.value = error?.response?.data?.error || 'Failed to load collections.';
              failActivityEntry(entry, error, { fallback: 'Failed to load collections.' });
              handleRequestError(error);
            } finally {
              collectionsLoading.value = false;
            }
          };

          const loadIndexes = async () => {
            if (!selectedCollection.value) return;
            indexesLoading.value = true;
            const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:listIndexes`;
            const entry = createActivityEntry({
              label: 'List indexes',
              method: 'POST',
              url,
              target: selectedCollection.value.name,
            });
            try {
              const resp = await axios.post(url);
              markConnectionOnline();
              const list = Array.isArray(resp.data) ? resp.data : [];
              indexes.value = list;
              completeActivityEntry(entry, {
                detail: `Loaded ${list.length} indexes.`,
                statusCode: resp.status,
              });
              if (!list.some((idx) => idx.name === selectedIndexName.value)) {
                selectedIndexName.value = '';
              }
            } catch (error) {
              indexes.value = [];
              failActivityEntry(entry, error, { fallback: 'Failed to load indexes.' });
              handleRequestError(error);
            } finally {
              indexesLoading.value = false;
            }
          };

          const parseFilter = () => {
            const raw = filterText.value.trim();
            if (!raw) {
              filterText.value = '{}';
              return {};
            }
            try {
              const parsed = JSON.parse(raw);
              filterError.value = '';
              return parsed;
            } catch (err) {
              filterError.value = 'Invalid JSON: ' + err.message;
              return null;
            }
          };

          const buildQueryPayload = () => {
            const parsedFilter = parseFilter();
            if (parsedFilter === null) {
              const error = new Error('invalid-filter');
              error.code = 'invalid-filter';
              throw error;
            }
            const payload = {
              filter: parsedFilter,
              limit: Number(pageSize.value) || 0,
              skip: offset.value,
            };
            const index = activeIndex.value;
            if (index) {
              payload.index = index.name;
              if (index.type === 'map') {
                if (!mapValue.value) {
                  const error = new Error('map-value-required');
                  error.code = 'map-value-required';
                  throw error;
                }
                payload.value = mapValue.value;
              } else if (index.type === 'btree') {
                payload.reverse = !!reverse.value;
                const fields = index.fields || [];
                if (fields.length && fields.every((field) => rangeFrom[field])) {
                  const from = {};
                  fields.forEach((field) => {
                    from[field] = rangeFrom[field];
                  });
                  payload.from = from;
                }
                if (fields.length && fields.every((field) => rangeTo[field])) {
                  const to = {};
                  fields.forEach((field) => {
                    to[field] = rangeTo[field];
                  });
                  payload.to = to;
                }
              }
            }
            return payload;
          };

          const runQuery = async () => {
            if (!selectedCollection.value) return;
            queryError.value = '';
            let payload;
            try {
              payload = buildQueryPayload();
            } catch (error) {
              if (error.code === 'invalid-filter') {
                queryError.value = 'The filter must be valid JSON.';
              } else if (error.code === 'map-value-required') {
                queryError.value = 'You must provide a value for the selected index.';
              } else {
                queryError.value = error.message || 'Failed to prepare the query.';
              }
              return;
            }
            queryLoading.value = true;
            const started = performance.now();
            const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:find`;
            const entry = createActivityEntry({
              label: 'Query documents',
              method: 'POST',
              url,
              target: selectedCollection.value.name,
            });
            try {
              const resp = await axios({
                method: 'post',
                url,
                data: payload,
                transformResponse: (res) => res,
                responseType: 'text',
              });
              const raw = resp.data || '';
              const lines = raw.split('\n').filter(Boolean);
              const parsedRows = lines.map((line) => {
                try {
                  return JSON.parse(line);
                } catch (err) {
                  return { _raw: line };
                }
              });
              queryRows.value = parsedRows;
              queryStats.returned = parsedRows.length;
              const elapsed = Math.round(performance.now() - started);
              queryStats.elapsed = `${elapsed} ms`;
              markConnectionOnline();
              completeActivityEntry(entry, {
                detail: `Retrieved ${parsedRows.length} documents in ${elapsed} ms.`,
                statusCode: resp.status,
              });
            } catch (error) {
              queryError.value = error?.response?.data?.error || 'Failed to fetch the collection.';
              failActivityEntry(entry, error, { fallback: 'Failed to fetch the collection.' });
              handleRequestError(error);
            } finally {
              queryLoading.value = false;
            }
          };

          const nextPage = () => {
            if (disableNext.value) return;
            page.value = Number(page.value) + 1;
            runQuery();
          };

          const prevPage = () => {
            if (disablePrev.value) return;
            page.value = Math.max(1, Number(page.value) - 1);
            runQuery();
          };

          watch(pageSize, (value, old) => {
            if (value === old) return;
            page.value = 1;
            runQuery();
          });

          const canEditRow = (row) => {
            const index = activeIndex.value;
            if (!index || index.type !== 'map' || !index.field) return false;
            if (!row || typeof row !== 'object' || row === null) return false;
            if (Object.prototype.hasOwnProperty.call(row, '_raw')) return false;
            return Object.prototype.hasOwnProperty.call(row, index.field);
          };

          const canDeleteRow = (row) => {
            const index = activeIndex.value;
            if (!index || index.type !== 'map' || !index.field) return false;
            if (!row || typeof row !== 'object' || row === null) return false;
            return Object.prototype.hasOwnProperty.call(row, index.field);
          };

          const deleteRow = async (row) => {
            const index = activeIndex.value;
            if (!selectedCollection.value || !index || index.type !== 'map' || !index.field) return;
            const value = row[index.field];
            if (value === undefined) {
              queryError.value = `The document does not contain the field "${index.field}".`;
              return;
            }
            const collectionName = selectedCollection.value.name;
            const valueLabel = formatValueLabel(value);
            const ok = window.confirm(`Delete the document where ${index.field} = ${valueLabel}?`);
            if (!ok) return;
            const url = `/v1/collections/${encodeURIComponent(collectionName)}:remove`;
            const entry = createActivityEntry({
              label: `Delete document by ${index.field}`,
              method: 'POST',
              url,
              target: collectionName,
            });
            try {
              const resp = await axios.post(url, {
                index: index.name,
                value,
                limit: 1,
              });
              markConnectionOnline();
              completeActivityEntry(entry, {
                detail: `Deleted document where ${index.field} = ${valueLabel}.`,
                statusCode: resp.status,
              });
              if (editDialog.open) {
                closeEditDialog();
              }
              await runQuery();
              await loadCollections();
            } catch (error) {
              queryError.value = error?.response?.data?.error || 'Failed to delete the document.';
              failActivityEntry(entry, error, { fallback: 'Failed to delete the document.' });
              handleRequestError(error);
            }
          };

          const insertDocument = async () => {
            insertForm.error = '';
            insertForm.success = '';
            if (!selectedCollection.value) {
              insertForm.error = 'Select a collection before inserting.';
              return;
            }
            let payload;
            try {
              payload = JSON.parse(insertForm.payload);
            } catch (err) {
              insertForm.error = 'Invalid JSON: ' + err.message;
              return;
            }
            const url = `/v1/collections/${encodeURIComponent(selectedCollection.value.name)}:insert`;
            const entry = createActivityEntry({
              label: 'Insert document',
              method: 'POST',
              url,
              target: selectedCollection.value.name,
            });
            try {
              const resp = await axios.post(url, payload);
              insertForm.success = 'Document inserted successfully.';
              insertForm.payload = '{\n\n}';
              markConnectionOnline();
              completeActivityEntry(entry, {
                detail: 'Document inserted successfully.',
                statusCode: resp.status,
              });
              await runQuery();
              await loadCollections();
            } catch (error) {
              insertForm.error = error?.response?.data?.error || 'Failed to insert the document.';
              failActivityEntry(entry, error, { fallback: 'Failed to insert the document.' });
              handleRequestError(error);
            }
          };

          const createCollection = async () => {
            createForm.error = '';
            const name = createForm.name.trim();
            if (!name) {
              createForm.error = 'Provide a name for the collection.';
              return;
            }
            const entry = createActivityEntry({
              label: `Create collection ${name}`,
              method: 'POST',
              url: '/v1/collections',
              target: name,
            });
            try {
              const resp = await axios.post('/v1/collections', { name });
              markConnectionOnline();
              const created = resp?.data?.name || name;
              completeActivityEntry(entry, {
                detail: `Collection "${created}" created successfully.`,
                statusCode: resp.status,
              });
              await loadCollections();
              selectedCollectionName.value = created;
              createForm.name = '';
              createForm.open = false;
            } catch (error) {
              createForm.error = error?.response?.data?.error || 'Failed to create the collection.';
              failActivityEntry(entry, error, { fallback: 'Failed to create the collection.' });
              handleRequestError(error);
            }
          };

          const dropCollection = async () => {
            if (!selectedCollection.value) return;
            const name = selectedCollection.value.name;
            const ok = window.confirm(`Delete the collection "${name}"? This action cannot be undone.`);
            if (!ok) return;
            const url = `/v1/collections/${encodeURIComponent(name)}:dropCollection`;
            const entry = createActivityEntry({
              label: `Delete collection ${name}`,
              method: 'POST',
              url,
              target: name,
            });
            try {
              const resp = await axios.post(url);
              markConnectionOnline();
              completeActivityEntry(entry, {
                detail: `Collection "${name}" deleted successfully.`,
                statusCode: resp.status,
              });
              selectedCollectionName.value = '';
              await loadCollections();
            } catch (error) {
              queryError.value = error?.response?.data?.error || 'Failed to delete the collection.';
              failActivityEntry(entry, error, { fallback: 'Failed to delete the collection.' });
              handleRequestError(error);
            }
          };

          const formatDocument = (row) => {
            if (row && typeof row === 'object' && '_raw' in row) {
              return row._raw;
            }
            try {
              return JSON.stringify(row, null, 2);
            } catch (err) {
              return String(row);
            }
          };

          onMounted(() => {
            beginConnectionCheck();
            loadCollections();
            statusPoller = window.setInterval(checkBackendStatus, 30000);
          });

          onBeforeUnmount(() => {
            if (statusPoller) {
              window.clearInterval(statusPoller);
              statusPoller = null;
            }
          });

          return {
            // state
            collections,
            collectionsLoading,
            collectionsError,
            selectedCollection,
            selectedCollectionName,
            indexes,
            indexesLoading,
            filterText,
            filterError,
            queryRows,
            queryLoading,
            queryError,
            queryStats,
            selectedIndexName,
            activeIndex,
            mapValue,
            reverse,
            rangeFrom,
            rangeTo,
            indexForm,
            indexMessages,
            insertForm,
            createForm,
            connectionStatus,
            activityLog,
            connectionStatusLabel,
            connectionStatusDescription,
            connectionStatusBadgeClass,
            connectionStatusDotClass,
            connectionStatusButtonLabel,
            connectionStatusChecking,
            disablePrev,
            disableNext,
            page,
            pageSize,
            pageSizeOptions,
            offset,
            pageInfo,
            editDialog,
            // methods
            prettyTotal,
            isSelected,
            toggleCreateForm,
            toggleIndexForm,
            selectCollection,
            runQuery,
            nextPage,
            prevPage,
            createIndex,
            removeIndex,
            insertDocument,
            createCollection,
            dropCollection,
            deleteRow,
            openEditDialog,
            closeEditDialog,
            submitEdit,
            canDeleteRow,
            canEditRow,
            formatDocument,
            refreshConnectionStatus,
            formatActivityTime,
            formatDuration,
            activityStatusLabel,
            activityStatusBadgeClass,
            clearActivityLog,
          };
        },
      }).mount('#app');
    </script>
  </body>
</html>
